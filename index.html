<!DOCTYPE html>
<html>
<head>

	<link rel="stylesheet" type="text/css" href="Editor/win95.css" />
	<link rel="stylesheet" type="text/css" href="Web/Poker.css" />

	<style>
	</style>

	<script src='PopEngineCommon/PopWebApi.js'></script>
	<script src='PopEngineCommon/PopApi.js'></script>
	<script src='PopEngineCommon/PopWebOpenglApi.js'></script>
	<script src='PopEngineCommon/PopWebGuiApi.js'></script>
	<script src='PopEngineCommon/PopWebImageApi.js'></script>
	<script src='PopEngineCommon/PopWebSocketApi.js'></script>
	<script src='PopEngineCommon/PopWebXrApi.js'></script>

</head>
<body>
	
	<div id="Variables">
		<h1>Variables</h1>
		<!-- variables -->
		<div id="Pot">0</div>
		<div id="RiverCard0">0</div>
		<div id="RiverCard1">0</div>
		<div id="RiverCard2">0</div>
		<div id="RiverCard3">0</div>
		<div id="RiverCard4">0</div>
		<div id="P1Card0">110</div>
		<div id="P1Card1">120</div>
		<div id="P1Bet">0</div>
		<div id="P2Card0">130</div>
		<div id="P2Card1">140</div>
		<div id="P2Bet">0</div>
		<div id="P3Card0">20</div>
		<div id="P3Card1">21</div>
		<div id="P3Bet">0</div>
		
	</div>
	
	<div id="Ux">
		<h1>Ux</h1>
		<div>Continue <input type=Button id="Ux_Continue" value="Continue"/></div>
		<div id="GameResult"></div>
	</div>
	
	
	<script>
		function SetInnerTextAttr(Element)
		{
			//console.log("SetInnerTextAttr",Element);
			Element.setAttribute('innerText',Element.innerText);
		}
	
		function SetVariable_InnerTextAttr()
		{
			const Vars = document.getElementById("Variables");
			Array.from(Vars.children).forEach( SetInnerTextAttr );
		}
		SetVariable_InnerTextAttr();
		
		
		function OnStateChanged(State)
		{
			function SetVariable(Key)
			{
				const Value = State[Key];
				const Element = document.getElementById(Key);
				if ( !Element )
					return;
				Element.innerText = Value;
			}
			Object.keys(State).forEach( SetVariable );
			SetVariable_InnerTextAttr();
		}
	
		function GetAllCards()
		{
			const Cards = [];
			//	numbers are 2-Ace(14)
			//	+ suit 1-4 (no zero for error testing)
			const Values = [2,3,4,5,6,7,8,9,10,11,12,13,14];
			const Suits = [1,2,3,4];
			for ( let v in Values )
			{
				for ( let s in Suits )
				{
					const Card = (Values[v] * 10) + Suits[s];
					Cards.push(Card);
				}
			}
			//console.log(Cards);
			return Cards;
		}
	
	
		const SMALL_BLIND = 5;
		const BIG_BLIND = SMALL_BLIND*2;
		const SUIT_HEART = 1;
		const SUIT_SPADE = 2;
		const SUIT_DIAMOND = 3;
		const SUIT_CLUB = 4;

		function PokerGameState()
		{
			this.CardDeck = GetAllCards();
			this.PopCard = function()
			{
				const Index = Math.floor( Math.random() * this.CardDeck.length );
				const Popped = this.CardDeck.splice( Index, 1 );
				return Popped[0];
			}
			
			this.GetHighestBet = function()
			{
				let Bet = 0;
				Bet = Math.max( Bet, this.P1Bet );
				Bet = Math.max( Bet, this.P2Bet );
				Bet = Math.max( Bet, this.P3Bet );
				return Bet;
			}
			
			this.Pot = 0;
			this.P1Bet = SMALL_BLIND;
			this.P2Bet = BIG_BLIND;
			this.P3Bet = 0;
			this.RiverCard0 = 0;
			this.RiverCard1 = 0;
			this.RiverCard2 = 0;
			this.RiverCard3 = 0;
			this.RiverCard4 = 0;
			this.P1Card0 = 0;
			this.P1Card1 = 0;
			this.P2Card0 = 0;
			this.P2Card1 = 0;
			this.P3Card0 = 0;
			this.P3Card1 = 0;
		}
	
		function CreatePromise()
		{
			const Prom = {};
			function SetResolveReject(Resolve,Reject)
			{
				Prom.Resolve = Resolve;
				Prom.Reject = Reject;
			}
			const NewPromise = new Promise(SetResolveReject);
			NewPromise.Resolve = Prom.Resolve;
			NewPromise.Reject = Prom.Reject;
			return NewPromise;
		}
	
		function CompareAscending(a,b)
		{
			return a - b;
		}
	
		function CompareDescending(a,b)
		{
			return b-a;
		}
	
		function IsBetFold(Bet)
		{
			//	-1 == -0
			//	anything else negative is how much they lost into the pot
			return Bet < 0;
		}
	
		function IsBetNotFold(Bet)
		{
			return !IsBetFold(Bet);
		}
	
		async function WaitForSync(State)
		{
			const ContinueButton = document.getElementById('Ux_Continue');
			const ContinuePromise = CreatePromise();
			ContinueButton.onclick = function()
			{
				ContinuePromise.Resolve();
				ContinueButton.onclick = undefined;
			}
			await ContinuePromise;
		}
	
		function GetCardValue(Card)
		{
			return Math.floor( Card / 10 );
		}
	
		function GetCardSuit(Card)
		{
			const Suit = (Card % 10);
			if ( Suit == 0 )
				throw "Invalid card";
			return Suit;
		}
	
		function IsHeart(Card)		{	return GetCardSuit(Card) == SUIT_HEART;		}
		function IsClub(Card)		{	return GetCardSuit(Card) == SUIT_CLUB;		}
		function IsSpade(Card)		{	return GetCardSuit(Card) == SUIT_SPADE;		}
		function IsDiamond(Card)	{	return GetCardSuit(Card) == SUIT_DIAMOND;		}

		
		function GetCardMaxValue()
		{
			return 14;	//	10, 11J, 12Q, 13K, 14ace
		}
	
		function GetCardMinValue()
		{
			return 2;
		}
	
		function GetSortedFiveCards(Cards)
		{
			function Compare(a,b)
			{
				const va = GetCardValue(a);
				const vb = GetCardValue(b);
				if ( va > vb )	return -1;
				if ( va < vb )	return 1;
				return 0;
			}
			Cards.sort( Compare );
			Cards.length = Math.min( 5, Cards.length );
			return Cards;
		}
	
		function GetNCardsWithValue(Cards,Value,Limit)
		{
			const VCards = Cards.filter( c => GetCardValue(c) == Value );
			VCards.length = Math.min( Limit, VCards.length );
			return VCards;
		}
	
		function GetCardToString(Card)
		{
			const Suits = ["x","&hearts;","&spades;","&diams;","&clubs;"];
			const Suit = Suits[GetCardSuit(Card)];
			let Value = GetCardValue(Card);
			if ( Value == 11 )	Value = "Jack";
			if ( Value == 12 )	Value = "Queen";
			if ( Value == 13 )	Value = "King";
			if ( Value == 14 )	Value = "Ace";
			return Suit + Value;
		}
	
		function GetHandToString(Cards)
		{
			const Names = Cards.map( GetCardToString );
			return Names.join(', ');
		}
	
		function GetStraightFlushHand(Cards)
		{
			function GetStraightHandOfSuit(IsSuitFunc)
			{
				const Hearts = Cards.filter( c => IsSuitFunc(c) );
				if ( Hearts.length < 5 )
					return false;
	
				const StraightHand = GetStraightHand(Hearts);
				return StraightHand;
			}
			
			const Hearts = GetStraightHandOfSuit( IsHeart );
			const Spades = GetStraightHandOfSuit( IsSpade );
			const Clubs = GetStraightHandOfSuit( IsClub );
			const Diamonds = GetStraightHandOfSuit( IsDiamond );
			if ( Hearts )	return Hearts;
			if ( Spades )	return Spades;
			if ( Clubs )	return Clubs;
			if ( Diamonds )	return Diamonds;
			return false;
		}
	
	
		function GetFlushHand(Cards)
		{
			const Hearts = Cards.filter( c => IsHeart(c) );
			const Spades = Cards.filter( c => IsSpade(c) );
			const Clubs = Cards.filter( c => IsClub(c) );
			const Diamonds = Cards.filter( c => IsDiamond(c) );
			if ( Hearts.length >= 5 )
				return GetSortedFiveCards(Hearts);
			if ( Spades.length >= 5 )
				return GetSortedFiveCards(Spades);
			if ( Clubs.length >= 5 )
				return GetSortedFiveCards(Clubs);
			if ( Diamonds.length >= 5 )
				return GetSortedFiveCards(Diamonds);
			return false;
		}
	
		function GetStraightHand(Cards)
		{
			const Values = Cards.map( GetCardValue );
			Values.sort(CompareDescending);
			//	remove duplicates
			const UniqueValues = [...new Set(Values)];
			if ( UniqueValues.length < 5 )
				return false;
				
			function IsSequence(Array)
			{
				for ( let i=1;	i<Array.length;	i++ )
					if ( Array[i-1] != Array[i]-1 )
						return false;
				return true;
			}
			
			//	for each number, count up 5 in a row
			//	in reverse to get best result first
			for ( let i=4;	i<UniqueValues.length;	i++ )
			{
				let Set = UniqueValues.slice( i-4, i+1 );
				if ( Set.length != 5 )	throw "Programmer error";
				if ( !IsSequence(Set) )
					continue;
	
				//	grab cards from original bunch that match this set
				function GetStraightCard(CardValue)
				{
					function MatchCardValue(Card)
					{
						return GetCardValue(Card) == CardValue;
					}
					const Card = Cards.find( MatchCardValue );
					if ( Card === undefined )	throw "Failed to match this card in original bunch";
					return Card;
				}
				const StraightCards = Set.map( GetStraightCard );
				return GetSortedFiveCards(StraightCards);
			}
			return false;
		}
	
	
		function GetFullHouseHand(Cards)
		{
			//	for any 5, is there 3 & 2...
			const Threes = [];
			const Pairs = [];
			const Values = Cards.map( GetCardValue );
			for ( let v=2;	v<=14;	v++ )
			{
				const MatchingValues = Values.filter( c => c==v );
				if ( MatchingValues.length >= 3 )
					Threes.push( v );
				if ( MatchingValues.length == 2 )
					Pairs.push( v );
			}
			if ( Threes.length == 0 || Pairs.length == 0 )
				return false;
			if ( Threes.length > 1 )
				Threes.sort(CompareDescending);
			if ( Pairs.length > 1 )
				Pairs.sort(CompareDescending);
			
			//	pick any 3 cards matching Threes[0]
			//	pick any 2 cards matching Pairs[0]
			const ThreeCards = GetNCardsWithValue( Cards, Threes[0], 3 );
			const PairCards = GetNCardsWithValue( Cards, Pairs[0], 2 );
			
			const FullHouseCards = ThreeCards.concat( PairCards );
			return GetSortedFiveCards( FullHouseCards );
		}
	
		function GetFourOfAKindHand(Cards)
		{
			const Values = Cards.map( GetCardValue );
			for ( let v=GetCardMaxValue();	v>=GetCardMinValue();	v-- )
			{
				const MatchingValues = Values.filter( c => c==v );
				if ( MatchingValues.length > 4 )
					throw "Invalid case, >4 four of a kind";
				if ( MatchingValues.length < 4 )
					continue;
				
				//	grab 4 cards with this value
				const Hand = GetNCardsWithValue( Cards, v, 4 );
				return Hand;
			}
			return false;
		}
	
	
		function GetThreeOfAKindHand(Cards)
		{
			const Values = Cards.map( GetCardValue );
			for ( let v=GetCardMaxValue();	v>=GetCardMinValue();	v-- )
			{
				const MatchingValues = Values.filter( c => c==v );
				if ( MatchingValues.length < 3 )
					continue;
				
				//	grab 3 cards with this value
				const Hand = GetNCardsWithValue( Cards, v, 3 );
				return Hand;
			}
			return false;
		}
	
		function GetTwoPairHand(Cards)
		{
			let PairHi = null;
			let PairLo = null;
			const Values = Cards.map( GetCardValue );
			for ( let v=GetCardMaxValue();	v>=GetCardMinValue();	v-- )
			{
				const MatchingValues = Values.filter( c => c==v );
				if ( MatchingValues.length < 2 )
					continue;
				if ( PairHi === null )
				{
					PairHi = v;
					continue;
				}
				if ( PairLo === null )
				{
					PairLo = v;
					break;
				}
			}
			if ( PairLo === null )
				return false;

			const HandHi = GetNCardsWithValue( Cards, PairHi, 2 );
			const HandLo = GetNCardsWithValue( Cards, PairLo, 2 );
			return HandHi.concat( HandLo );
		}
	
		function GetOnePairHand(Cards)
		{
			const Pairs = [];
			const Values = Cards.map( GetCardValue );
			for ( let v=2;	v<=14;	v++ )
			{
				const MatchingValues = Values.filter( c => c==v );
				if ( MatchingValues.length >= 2 )
					Pairs.push( v );
			}
			if ( Pairs.length == 0 )
				return false;
			
			//	get pairs with highest value
			//	now grab any card from the best pair set
			if ( Pairs.length > 1 )
				Pairs.sort(CompareDescending);
			const Hand = GetNCardsWithValue( Cards, Pairs[0], 2 );
			return Hand;
		}
	
		function GetHighCardHand(Cards)
		{
			const Values = Cards.map( GetCardValue );
			let BestIndex = 0;
			for ( let i=0;	i<Values.length;	i++ )
				if ( Values[i] > Values[BestIndex] )
					BestIndex = i;
			return [Cards[BestIndex]];
		}
	
		function GetHandScore(Cards)
		{
			//	X000 + HighV gives a unique value
			function GetScore(GetHandFunc,FuncScore)
			{
				const Hand = GetHandFunc( Cards );
				if ( Hand === false )
					return 0;
				let Score = FuncScore * 1000;
				const HighCardValue = GetCardValue(Hand[0]);
				Score += HighCardValue;
				return Score;
			}
			const GetHandFuncs =
			[
			 GetStraightFlushHand,
			 GetFourOfAKindHand,
			 GetFullHouseHand,
			 GetFlushHand,
			 GetStraightHand,
			 GetThreeOfAKindHand,
			 GetTwoPairHand,
			 GetOnePairHand,
			 GetHighCardHand
			];
			for ( let f=0;	f<GetHandFuncs.length;	f++ )
			{
				const FuncScore = GetHandFuncs.length - f;
				const Score = GetScore( GetHandFuncs[f], FuncScore );
				if ( Score != 0 )
					return Score;
			}
			throw "Shouldn't reach here";
		}
	
	
		function CompareBestHands(PlayerA,PlayerB)
		{
			//	need to re-classify these hands, oops. maybe need a score/id for type
			const ScoreA = GetHandScore( PlayerA.BestHand );
			const ScoreB = GetHandScore( PlayerB.BestHand );
			if ( ScoreA > ScoreB )
				return -1;
			if ( ScoreB > ScoreA )
				return 1;
			return 0;
		}
	
		function CompareHands(PlayerA,PlayerB)
		{
			function Compare(CardFunc)
			{
				const a = CardFunc(PlayerA.Cards);
				const b = CardFunc(PlayerB.Cards);
				if ( a!==false && b===false )
					return -1;
				if ( a===false && b!==false )
					return 1;
				if ( a!==false && b!==false )
				{
					const HighA = GetCardValue(a[0]);
					const HighB = GetCardValue(b[0]);
					if ( HighA > HighB )
						return -1;
					if ( HighB > HighA )
						return 1;
				}
				//	tie
				return 0;
			}
			
			const StraightFlush = Compare( GetStraightFlushHand );
			if ( StraightFlush != 0 )
				return StraightFlush;
				
			const Four = Compare( GetFourOfAKindHand );
			if ( Four != 0 )
				return Four;
				
			const FullHouse = Compare( GetFullHouseHand );
			if ( FullHouse != 0 )
				return FullHouse;
				
			const Flush = Compare( GetFlushHand );
			if ( Flush != 0 )
				return Flush;
				
			const Straight = Compare( GetStraightHand );
			if ( Straight != 0 )
				return Straight;
				
			const Three = Compare( GetThreeOfAKindHand );
			if ( Three != 0 )
				return Three;
				
			const Pair2 = Compare( GetTwoPairHand );
			if ( Pair2 != 0 )
				return Pair2;
			
			const Pair = Compare( GetOnePairHand );
			if ( Pair != 0 )
				return Pair;
			
			const High = Compare( GetHighCardHand );
			if ( High != 0 )
				return High;

			return 0;
		}
	
		function GetBestHand(Cards)
		{
			const GetHandFuncs =
			[
			 GetStraightFlushHand,
			 GetFourOfAKindHand,
			 GetFullHouseHand,
			 GetFlushHand,
			 GetStraightHand,
			 GetThreeOfAKindHand,
			 GetTwoPairHand,
			 GetOnePairHand,
			 GetHighCardHand
			];
			for ( let f=0;	f<GetHandFuncs.length;	f++ )
			{
				const GetHandFunc = GetHandFuncs[f];
				const Hand = GetHandFunc( Cards );
				if ( Hand === false )
					continue;
				return Hand;
			}
			throw "Shouldn't reach here, GetHighCardHand should always give a result";
		}
	
		function GetPlayerState(State,Player)
		{
			const Card0 = State['P'+Player+'Card0'];
			const Card1 = State['P'+Player+'Card0'];
			const Bet = State['P'+Player+'Bet'];

			let Cards = [ Card0, Card1, State.RiverCard0, State.RiverCard1, State.RiverCard2, State.RiverCard3, State.RiverCard4 ];
			const Hand = {};
			Hand.Player = Player;
			Hand.Cards = Cards;
			Hand.BestHand = GetBestHand(Cards);
			Hand.Bet = Bet;
			return Hand;
		}
	
		function GetWinner(State)
		{
			//	get cards of those who havent folded
			let Hands = [];
			
			function PushHand(Player)
			{
				const PlayerState = GetPlayerState(State,Player);
				if ( IsBetFold(PlayerState.Bet) )
					return;
				Hands.push(PlayerState);
			}
			PushHand( 1 );
			PushHand( 2 );
			PushHand( 3 );
			
			if ( Hands.length == 0 )
				throw "Everyone folded, unexpected state";
			
			Hands.sort( CompareBestHands );
			//	todo: check for everyone using river cards & tie
			return Hands[0];
		}
	
	
		async function ShowNewGame(State)
		{
			const StateElement = document.getElementById('GameResult');
			StateElement.innerHTML = '';
		}
	
		async function ShowWinner(State)
		{
			const Winner = GetWinner(State);
			
			const Prize = State.Pot + Math.max(0,State.P1Bet) + Math.max(0,State.P2Bet) + Math.max(0,State.P3Bet);
			
			const StateElement = document.getElementById('GameResult');
			StateElement.innerHTML = 'Winner is ' + Winner.Player + "<br/>";
			StateElement.innerHTML += 'With ' + GetHandToString(Winner.BestHand) + "<br/>";
			StateElement.innerHTML += 'Wins $' + Prize + "<br/>";
			StateElement.innerHTML += "<br/>";

			function GetLoserSummary(Player)
			{
				const PlayerState = GetPlayerState(State,Player);
				let Loss = PlayerState.Bet;
				if ( !IsBetFold(Loss) )
				{
					//	gr: this will always be zero. running loss/bet is not in state
					Loss = -Loss;
				}
				else if ( Loss == -1 )
				{
					Loss = 0;
				}
				let Summary = "Player " + Player + " lost $" + Loss + "<br/>";
				Summary += "With " + GetHandToString( PlayerState.BestHand );
				return Summary;
			}
			
			if ( Winner.Player != 1 )
				StateElement.innerHTML += GetLoserSummary(1) + "<br/><br/>";
			if ( Winner.Player != 2 )
				StateElement.innerHTML += GetLoserSummary(2) + "<br/><br/>";
			if ( Winner.Player != 3 )
				StateElement.innerHTML += GetLoserSummary(3) + "<br/><br/>";

			await WaitForSync();
		}
	
		function RevealNextCard(State)
		{
			//	havent shown player cards
			if ( State.P1Card0 == 0 )
			{
				console.log("Deal");
				State.P1Card0 = State.PopCard();
				State.P1Card1 = State.PopCard();
				State.P2Card0 = State.PopCard();
				State.P2Card1 = State.PopCard();
				State.P3Card0 = State.PopCard();
				State.P3Card1 = State.PopCard();
				return;
			}
			
			if ( State.RiverCard0 == 0 )
			{
				console.log("Flop");
				State.RiverCard0 = State.PopCard();
				State.RiverCard1 = State.PopCard();
				State.RiverCard2 = State.PopCard();
				return;
			}
			
			if ( State.RiverCard3 == 0 )
			{
				console.log("Turn");
				State.RiverCard3 = State.PopCard();
				return;
			}
			
			if ( State.RiverCard4 == 0 )
			{
				console.log("River");
				State.RiverCard4 = State.PopCard();
				return;
			}

			throw "No more cards to turn";
		}
	
		async function UpdateGame()
		{
			const State = new PokerGameState();
			OnStateChanged( State );
			await ShowNewGame(State);

			await WaitForSync(State);
			
			//	preflop
			await UpdateRound(State);
			await WaitForSync(State);
			
			//	flop
			await UpdateRound(State);
			await WaitForSync(State);

			//	turn
			await UpdateRound(State);
			await WaitForSync(State);

			//	river
			await UpdateRound(State);
			await WaitForSync(State);

			//	finished
			return State;
		}
	
		function GetStateBettingPlayerCount(State)
		{
			let Bets = [State.P1Bet,State.P2Bet,State.P3Bet];
			Bets = Bets.filter( IsBetNotFold );
			
			return Bets.length;
		}
	
		function StateNeedsBet(State)
		{
			//	if any player is less bet than others and not folded
			let Bets = [State.P1Bet,State.P2Bet,State.P3Bet];
			Bets = Bets.filter( IsBetNotFold );
			if ( Bets.length == 0 )
				throw "Nobody valid for betting";
			
			//	only one player left
			if ( Bets.length == 1 )
				return false;
				
			//	all bets are same!
			const BetsAreSame = Bets.every( b => b==Bets[0] );
			return !BetsAreSame;
		}
	
		async function GetPlayerAction(State,PXBet)
		{
			const Actions =
			[
				'FOLD',
			 	'CALL','CALL','CALL','CALL','CALL','CALL','CALL','CALL',
			 	'RAISE','RAISE','RAISE','RAISE'
			];
			
			//	already folded
			if ( IsBetFold(State[PXBet]) )
				return 'FOLD';//Actions[0];
	
			//	if everyone else folded, just call
			const PlayerCount = GetStateBettingPlayerCount(State);
			if ( PlayerCount == 1 )
				return 'CALL';
	
			//	pick random action
			//	fold, call, raise
			const ActionIndex = Math.floor(Math.random() * Actions.length);
			console.log(PXBet+" "+Actions[ActionIndex]+"s");
			return Actions[ActionIndex];
		}
		async function GetPlayer1Action(State,PXBet)	{	return await GetPlayerAction(State,'P1Bet');	}
		async function GetPlayer2Action(State,PXBet)	{	return await GetPlayerAction(State,'P2Bet');	}
		async function GetPlayer3Action(State,PXBet)	{	return await GetPlayerAction(State,'P3Bet');	}


		function ApplyPlayerAction(State,Action,PXBet)
		{
			if ( Action == 'FOLD' )
			{
				//	already folded
				if ( IsBetFold(State[PXBet]) )
					return;
				//	when bet is negative, it's everything we've lost
				//	-1 is a special case where it's a fold, but lost nothing (-0)
				State.Pot += State[PXBet];
				State[PXBet] = Math.min( -1, -State[PXBet] );
				return;
			}
			
			if ( Action == 'CALL' )
			{
				//	steal from player
				State[PXBet] = State.GetHighestBet();
				return;
			}
			
			if ( Action == 'RAISE' )
			{
				//	steal from player
				State[PXBet] = State.GetHighestBet() + BIG_BLIND;
				return;
			}
			throw "Unhandled action " + Action;
		}
		function ApplyPlayer1Action(State,Action)	{	return ApplyPlayerAction(State,Action,'P1Bet');	}
		function ApplyPlayer2Action(State,Action)	{	return ApplyPlayerAction(State,Action,'P2Bet');	}
		function ApplyPlayer3Action(State,Action)	{	return ApplyPlayerAction(State,Action,'P3Bet');	}

		function FlushBets(State)
		{
			State.Pot += Math.max( 0, State.P1Bet );
			State.Pot += Math.max( 0, State.P2Bet );
			State.Pot += Math.max( 0, State.P3Bet );
			State.P1Bet = Math.min( State.P1Bet, 0 );
			State.P2Bet = Math.min( State.P2Bet, 0 );
			State.P3Bet = Math.min( State.P3Bet, 0 );
		}
		
		async function UpdateRound(State)
		{
			RevealNextCard(State);
			OnStateChanged(State);
			do
			{
				const P1Action = await GetPlayer1Action(State);
				ApplyPlayer1Action(State,P1Action);
				OnStateChanged(State);
				const P2Action = await GetPlayer2Action(State);
				ApplyPlayer2Action(State,P2Action);
				OnStateChanged(State);
				const P3Action = await GetPlayer3Action(State);
				ApplyPlayer3Action(State,P3Action);
				OnStateChanged(State);
			}
			while ( StateNeedsBet(State) )
			
			FlushBets(State);
			OnStateChanged(State);
		}
	
	
		async function Bootup()
		{
			const Contest = undefined;
			while ( true )	//	( contest.hasplayers )
			{
				const EndingState = await UpdateGame( Contest );
				//	remove players that have 0 cash
				//	announce winner
				await ShowWinner(EndingState);
			}
		}
	
		Bootup().then(console.log).catch(console.error);
	
		/*
		async function Bootup()
		{
			const Source = await Pop.LoadFileAsStringAsync('bootup.js');
			Pop.CompileAndRun( Source, 'bootup.js' );
		}

		Bootup().then( e=>Pop.Debug("Finished!",e) ).catch( console.error );
	*/
	</script>
	
</body>

